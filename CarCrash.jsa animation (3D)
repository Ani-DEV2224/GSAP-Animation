<!DOCTYPE html>
<html>
<head>
    <title>Realistic Car Crash Scene</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Sky.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add realistic sky
        const sky = new THREE.Sky();
        sky.scale.setScalar(10000);
        scene.add(sky);

        const skyUniforms = sky.material.uniforms;
        skyUniforms['turbidity'].value = 1;
        skyUniforms['rayleigh'].value = 1;
        skyUniforms['mieCoefficient'].value = 0.005;
        skyUniforms['mieDirectionalG'].value = 0.8;
        skyUniforms['sunPosition'].value.set(0, 100, -50);

        // Enhanced lighting
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
        hemiLight.position.set(0, 100, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(-0.5, 1, -0.5);
        scene.add(dirLight);

        // Create terrain with mountains
        function createMountain() {
            const geometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            const material = new THREE.MeshPhongMaterial({ color: 0x4d3900 });
            
            // Displace vertices to create mountain shapes
            const vertices = geometry.attributes.position.array;
            for(let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.random() * 30; // Z-axis displacement
            }
            
            const mountain = new THREE.Mesh(geometry, material);
            mountain.rotation.x = -Math.PI / 2;
            mountain.position.y = -2;
            return mountain;
        }

        // Add mountains around the scene
        scene.add(createMountain().rotateZ(Math.PI/4));
        scene.add(createMountain().rotateZ(-Math.PI/4));

        // Create road
        const roadGeometry = new THREE.PlaneGeometry(20, 200);
        const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2;
        road.position.y = -1.9;
        scene.add(road);

        // Add road markings
        function createRoadMarking() {
            const marking = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.2, 0.5),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            marking.position.z = Math.random() * 100 - 50;
            return marking;
        }

        for(let i = 0; i < 20; i++) {
            const marking = createRoadMarking();
            marking.position.x = i % 2 === 0 ? -0.5 : 0.5;
            scene.add(marking);
        }

        // Create trees
        function createTree() {
            const tree = new THREE.Group();
            
            // Trunk
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.5, 3),
                new THREE.MeshPhongMaterial({ color: 0x4a2b0f })
            );
            
            // Leaves
            const leaves = new THREE.Mesh(
                new THREE.SphereGeometry(2),
                new THREE.MeshPhongMaterial({ color: 0x00ff00 })
            );
            leaves.position.y = 2;
            
            tree.add(trunk, leaves);
            return tree;
        }

        // Add trees on both sides of the road
        for(let i = -80; i < 80; i += 10) {
            const tree1 = createTree();
            tree1.position.set(-12, -2, i);
            scene.add(tree1);

            const tree2 = createTree();
            tree2.position.set(12, -2, i);
            scene.add(tree2);
        }

        // ... [Keep previous car creation code from earlier version] ...
        // ... [Keep logo implementation code from previous version] ...

        // Position camera
        camera.position.set(0, 15, 30);
        camera.lookAt(0, 0, 0);

        // Animation variables
        let crashOccurred = false;
        const speed = 0.3;

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if(!crashOccurred) {
                car1.position.x += speed;
                car2.position.x -= speed;

                if(car1.position.x >= 0 && car2.position.x <= 0) {
                    crashOccurred = true;
                    car1.rotation.z = -0.2;
                    car2.rotation.z = 0.2;
                    car1.position.y = 0.5;
                    car2.position.y = 0.5;
                    if(logoMesh) logoMesh.visible = true;
                }
            }

            // Rotate sky
            sky.material.uniforms['sunPosition'].value.rotateY(0.0001);

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        animate();
    </script>
</body>
</html>
        // ... [Keep rest of the animation and scene setup code] ...
    </script>
</body>
</html>
